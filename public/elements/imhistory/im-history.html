<link rel="import" href="/platform/bower_components/polymer/polymer.html">
<link rel="import" href="/platform/bower_components/core-style/core-style.html">
<link rel="import" href="/platform/bower_components/paper-toast/paper-toast.html">
<link rel="import" href="/platform/elements/member-select/member-element.html">
<link rel="import" href="/platform/elements/app-globals/app-globals.html">

<link rel="import" href="../display-item/display-item.html">

<!--<link rel="import" href="../event-infinite-scroll/event-infinite-scroll.html">-->
<link rel="import" href="/platform/bower_components/event-infinite-scroll/event-infinite-scroll.html">

<script src="../../bower_components/async/lib/async.js"></script>
<script src="../../bower_components/lodash/dist/lodash.min.js"></script>

<!--

channel is useful

-->
<polymer-element name="im-history" extends="div" attributes="channel">

    <template>
        <app-globals id="globals"></app-globals>
        <core-style ref="theme"></core-style>

        <style>
            :host {
                overflow: auto;
            }

        </style>
        <event-infinite-scroll flex id="infiniteScroll" data="{{items}}" on-loading-up="{{reachedTop}}" up>
            <template repeat="{{item in items}}">
                <display-item item="{{item}}"></display-item>
            </template>

        </event-infinite-scroll>
        </div>


        <div>
            <paper-toast id="comingMessageToast" text="New Message">
                from
                <member-element userid="{{comingMessage.userId}}"></member-element>
            </paper-toast>
        </div>
    </template>
    <script>
        (function () {
            var serverUrl = 'undefined';

            Polymer('im-history', {
                items: [],
                newMessage: false,
                noMoreHistory: false,
                ready: function () {
                    this.init = _initImHistory;
                    this.reachedTop = _reachedTop;
                    this.loadHistory = _loadHistory;
                    this.messageReady = _messageReady;
                    this.messageLoaded = _messageLoaded;
                    this.sendMessage = _sendMessage;
                    this.receiveMyMessage = _receiveMyMessage;
                    this.confirmSended = _confirmSended;
                },

                domReady: function () {
                    this.imGlobals = this.$.globals.values.im;
                    serverUrl = this.imGlobals.serverUrl;
                }
            });

            function _initImHistory() {
                var deferred = $.Deferred();
                var self = this;
                _scrollToBottom.call(self);
                async.waterfall([
                    function (callback) {
                        $.get(serverUrl + '/api/channels/' + self.channel.id + '/messages/lastSeen')
                                .done(function (lastSeenMessage) {
                                    callback(null, lastSeenMessage);
                                });
                    },
                    function (lastSeenMessage, callback) {
                        if (!lastSeenMessage) {
                            callback();
                        } else {
                            _getLastSeenMessages.call(self, lastSeenMessage.messageId).done(function () {
                                callback();
                            })
                        }
                    },
                    function (callback) {
                        _loadHistory.call(self).done(function () {
                            callback();
                        })
                    }

                ], function (err) {
                    deferred.resolve({
                        status: 200,
                        error: err
                    })
                });
                return deferred;
            }

            function _reachedTop(event, detail, target) {
                var historyLimit = 10;

                if (this.noMoreHistory) {
                    detail.callback([]);
                    return;
                }
                if (this.items.length < 1) {
                    return;
                }
                if (this.items[0].value.id == null) {
                    return;
                }
                var self = this;
                return $.get(serverUrl + '/api/channels/' + self.channel.id +
                '/messages?beforeId=' + this.items[0].value.id +
                '&limit=' + historyLimit).done(function (messages) {
                    var temp = _wrapMessages(messages, false);
                    if (messages.length < historyLimit) {
                        self.noMoreHistory = true;
                        temp.unshift({type: 'nomorebar'});
                        self.$.infiniteScroll.removeAttribute('up');
                    }
                    detail.callback(temp);
                });
            }

            function _loadHistory(roomId) {
                var self = this;
                var unseenMessageId = 0;
                var beforeOption = '';
                if (this.items.length > 0) {
                    var id = undefined;
                    this.items.every(function (msg) {
                        if (msg.value.id) {
                            id = msg.value.id;
                            return false;
                        }
                        return true;
                    });
                    if (id) {
                        beforeOption = '&beforeId=' + id;
                    }
                }

                return $.get(serverUrl + '/api/channels/' + self.channel.id + '/messages?limit=30' + beforeOption).done(function (messages) {
                    _insertFrontMessages.call(self, messages, false);
                });
            }

            function _wrapMessages(messages, diableEvent) {
                var temp = [];
                var self = this;
                var count = 0;
                var lastMessage = null;
                messages.forEach(function (message) {
                    if (count === 4) {
                        message.hideMemberElement = false;
                        count = 0;
                    } else {
                        message.hideMemberElement = _isHideMemberElement(lastMessage, message);
                    }
                    if (message.hideMemberElement) {
                        count++;
                    }
                    message.disableEvent = diableEvent;
                    message.displayPreview = 'previewHidden';
                    temp.push({type: 'message', value: message});
                    lastMessage = message;
                });
                return temp;
            }

            function _insertFrontMessages(messages, diableEvent) {
                var temp = _wrapMessages(messages, diableEvent);
                this.items = temp.concat(this.items);
                _scrollToBottom.call(this);
            }

            function _scrollToBottom() {
                this.$.infiniteScroll.scrollToBottom();
            }

            function _isHideMemberElement(lastMessage, newMessage) {

                if (!lastMessage || !newMessage) {
                    return false;
                }
                var lastUserId = lastMessage.UserId;
                if (!lastUserId) {
                    lastUserId = lastMessage.userId;
                }
                var newUserId = newMessage.UserId;
                if (!newUserId) {
                    newUserId = newMessage.userId;
                }
                if (!lastMessage || !lastUserId || !newUserId || !newMessage.updatedAt || !lastMessage.updatedAt) {
                    return false;
                }
                if (lastUserId === newUserId &&
                        new Date(newMessage.updatedAt).getTime() - new Date(lastMessage.updatedAt).getTime() < 60 * 1000) {
                    return true;
                }
                return false;

            }

            function _messageReady(event) {
                var self = this;
                if (_atBottom.call(self)) {
                    _scrollToBottom.call(self);
                }
            }

            function _atBottom() {
                return this.scrollTop === (this.scrollHeight - this.clientHeight);
            }

            function _messageLoaded(event) {
                if (_atBottom.call(this)) {
                    // at the bottom
                    for (var i = this.items.length - 1; i >= 0; i--) {
                        if (this.items[i].value.guid === event.detail.messageGuid) {
                            this.items[i].value.displayPreview = '';
                            break;
                        }
                    }
                    _scrollToBottom.call(this);
                } else {
                    // not at bottom
                    for (var i = this.items.length - 1; i >= 0; i--) {
                        if (this.items[i].value.guid === event.detail.messageGuid) {
                            this.items[i].value.displayPreview = '';
                            break;
                        }
                    }
                }
            }

            function _sendMessage(msg) {
                if (this.newMessage) {
                    for (var i = this.items.length - 1; i >= 0; i--) {
                        if (!this.items[i].value.userId && this.items[i].value.text === 'NEW MESSAGES') {
                            this.items.splice(i, 1);
                            this.newMessage = false;
                            break;
                        }
                    }
                }
                var lastMsg = this.items[this.items.length - 1];
                if (lastMsg.value.userId && lastMsg.value.text === 'NEW MESSAGES') {
                    lastMsg = this.items[this.items.length - 2];
                }
                msg.updatedAt = new Date();
                msg.hideMemberElement = _isHideMemberElement(lastMsg.value, msg);
                this.items.push({type: 'message', value: msg});
                _scrollToBottom.call(this);
            }

            function _confirmSended(message) {
                var self = this;
                for (var i = self.items.length - 1; i >= 0; i--) {
                    if (self.items[i].value.guid === message.guid) {
                        self.items[i].value = message;
                        if (i - 1 >= 0) {
                            self.items[i].value.hideMemberElement =
                                    _isHideMemberElement.call(self, self.items[i - 1].value, message);
                        }
                        break;
                    }
                }
            }

            function _getLastSeenMessages(lastSeenMessageId) {
                var self = this;

                return $.get(serverUrl + '/api/channels/' + this.channel.id + '/messages?sinceId=' + lastSeenMessageId)
                        .done(function (messages) {
                            _insertFrontMessages.call(self, messages, false);
                        })
                        .done(function () {
                            if (self.items.length > 0) {
                                var message = {text: 'NEW MESSAGES'};
                                self.items.splice(0, 0, {type: 'message', value: message});
                                self.newMessage = true;
                                self.fire('message-seen', {
                                    channel: self.channel,
                                    message: self.items[self.items.length - 1].value
                                })
                            }
                        });
            }

            function _receiveMyMessage(message) {
                var self = this;

                if (self.items.length > 0) {
                    message.hideMemberElement =
                            _isHideMemberElement.call(self, self.items[self.items.length - 1].value, message);
                }
                if (_atBottom.call(self)) {
                    message.disableEvent = false;
                } else {
                    self.comingMessage = {
                        userId: message.userId,
                        text: message.text
                    };
                    message.disableEvent = true;
                    self.$.comingMessageToast.show();
                }
                message.displayPreview = 'previewHidden';
                self.items.push({type: 'message', value: message});

                self.fire('message-seen', {
                    channel: self.channel,
                    message: self.items[self.items.length - 1].value
                })
            }
        })();
    </script>

</polymer-element>
